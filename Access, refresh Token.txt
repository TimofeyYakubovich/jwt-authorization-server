JWT представляет из себя обычную закодированую строку 
эта строка состоит из 3 частей разделенных точкой
заголовок header полезные данные payload и подпись signature

заголовок интересует нас меньше всего 
{
    "alg": "HS512",
    "typ": "JWT"
}
обезательо должен хранить с помощью какова алгоритма происходит шифрование
и необезательным может хранить тип ткена и др.


полезные данные payload вшиываем в токен уже сами
чаще всего это информация о пользователе каторый проходит авторизацию
{
id: 1;
username: 'Ulb TV';
roles: ['admin', 'manager']
}
заголовок и данные хрняться посути в открыто виде и раскодировать их может посути каждый поэтому хронить тут важную информацию типа паролей не состоит


signature что бы сигнатуру получить нужен некий секретный ключ этот ключ знает только сервер
берется заголовок + полезные данные payload и с помощью секретного ключа это все кодируется и на выходе получаем сигнатуру
эта сигнатура нужна для того что бы убедиться в том что токен не был подделан
если не знать секретный ключ эту сигнатуру получить практически невозможно


ACCESS REFRESH ТОКЕНЫ
каждый JWT токен имеет срок своей жизни через какое то время он становится невалиден и умрает это сдлеано для безопастности если машенник ваш
токен украл то он сможет попользоваться вашем сервисом время жизни токена 15 20 мин

как получать новый токен что бы каждый 15 20 мин не логиниться заново
для этого придумано 2 типа токенов токен доступа (ACCESS токен) и токен каторый этот ACCESS токен перезаписывает (REFRESH токен)

ACCESS токен живет 15 30 мин может изменяться до 1 - 3 суток чем меньше те безопастнее
REFRESH токен живет 15 - 60 дней тоесть если в течении 2 недель пользватель не посещал ваш сервис ему придется заново залогиниться 

ACCESS токен на стороне клиента чаще всего хрониться в localstorage в браузере
REFRESH токен хрониться в httpOnly cookie

влаг httpOnly является очень важным условием что бы через JS невозможно было эти куки изменить тоесть куки будет устанавливать непосредственно 
только сервер, REFRESH токен также записывается в бд на сервере и получается своего рода ссесия, туда можно записывать так же ip адрес с 
каторого произошло подключение и в случае если там был обнаружен новый ip адрес то можно отправлять пользователю уведомление о там что 
кто то зашел с другова устройства
или вместо ip адреса можно запоминать браузер с каторого произошла авторизация 


Взаимодействие клиента и сервера

пользователь откырвает приложение вводит email и пароль и нажимает кнопку войти
в теле запроса мы указывае этот {email, password} и отправляем на сервер
после сервер генерирует нам ACCESS и REFRESH ТОКЕНЫ
ACCESS токен сразу сохроняем в localstorage а REFRESH токен нам уже сервер установил в куки

пользователь успешно залогинился вошел в приложение и отправляется запрос например на плучение сообщений GET /api/messages
допустим это социальная сеть
к этому запросу мы добовляем хедер и записываем туда accessToken headers: Authorization: ${accessToken} и отправляем запрос на сервер
первое что делает сервер проверят токен если он валидный непотделаный и у него не истек срок годности то сервер возвращает status: 200
и возвращает сообщение каторое мы запросили

но если истек срок годности accessToken то он не валидный сервер возвращает status: 401 body: {message: 'HE АВТОРИЗОВАН’}
такое поведение на клиенте должно быть предусмотрено и на 401 код должен стоять перехватчик тоесть интерцептор 
в момент когда получили 401 статус код срзу же отправляем запрос на обновление accessToken /api/refresh cookie: refreshToken
в куках у нас уже находится refreshToken поэтому добовлять его никуда не надо тправляется запрос с этим токеном
сервер этот токен обрабатывает проверяет сверяет с тем каторый лежит в бд после возвращает новую пару access и refresh токенов

псоле того как срок годности access ткена пройдет процедура повторится